<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="dark-mode">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- BEGIN opengraph metadata -->
<meta property="og:title" content="SolarResult Dinnis Core API Documentation" />
<meta property="og:description" content="API documentation for SolarResult Dinnis Core - IoT firmware for smart meter gateway device built with Zephyr RTOS on Nordic nRF9161" />
<!-- END opengraph metadata -->
<!-- Favicon -->
<link rel="icon" type="image/svg+xml" href="solar_result_white.svg">
<title>SolarResult Dinnis Core: P1 DSMR Module - Documentatie</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript">
    // Initialize Doxygen Awesome features (dark mode only, no toggle)
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="solar_result_white.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SolarResult Dinnis Core
   </div>
   <div id="projectbrief">Dinnis Rev1.0.0 Firmware - IoT Gateway for DSMR P1 Smart Meters</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('p_one_doc.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">P1 DSMR Module - Documentatie </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_modules_2p__one_2p__one__doc"></a></p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md94"></a>
üîó Navigatie</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Sectie  </th><th class="markdownTableHeadNone">Link  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">üìö <b>API Referentie</b>  </td><td class="markdownTableBodyNone"><a class="el" href="group__p__one.html">P1 DSMR - API Referentie</a> - Module groep met alle functies, structs, en macros  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">üìÑ <b>Source Files</b>  </td><td class="markdownTableBodyNone"><a class="el" href="p__one_8c.html">p_one.c</a> - Implementatie  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">üìÑ <b>Header Files</b>  </td><td class="markdownTableBodyNone"><a class="el" href="p__one__zbus_8h.html">p_one_zbus.h</a> - Public API en data structures  </td></tr>
</table>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md96"></a>
Overzicht</h1>
<p>De P1 module vormt de kern van de energiemeting in Dinnis. Via de P1 poort van DSMR slimme meters leest de module elektriciteits- en gasverbruiksdata uit, parsed deze, en publiceert geaggregeerde statistieken voor cloud upload. Deze module draait continu in een dedicated thread en moet robuust omgaan met verschillende UART situaties, timing requirements, en data validatie.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md97"></a>
Functionaliteit</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md98"></a>
Data Acquisitie van DSMR Meters</h2>
<p>DSMR slimme meters publiceren elke seconde een telegram via de P1 poort - een seri√´le UART verbinding (115200 baud, 8N1, no flow control). Een telegram is een ASCII bestand bestaande uit OBIS codes (Object Identification System) die energie metingen representeren. De module luistert naar deze telegrams en extract relevante metingen:</p>
<p><b>Elektriciteit:</b></p><ul>
<li>Cumulatieve energie verbruik (van net) - tarief 1 en 2</li>
<li>Cumulatieve energie teruglevering (naar net) - tarief 1 en 2 <br  />
</li>
<li>Actueel vermogen verbruik (W)</li>
<li>Actueel vermogen teruglevering (W)</li>
</ul>
<p><b>Gas:</b></p><ul>
<li>Cumulatief gasverbruik (m¬≥)</li>
<li>Timestamp van laatste gas meting (gas wordt elk uur ge√ºpdatet, niet elke seconde)</li>
</ul>
<p>Elk OBIS veld heeft een vaste structuur: <span class="tt">OBIS-code(value*unit)</span>. Bijvoorbeeld: </p><div class="fragment"><div class="line">1-0:1.8.1(002841.463*kWh)  ‚Üí Verbruik tarief 1: 2841.463 kWh</div>
<div class="line">1-0:2.8.1(001244.927*kWh)  ‚Üí Teruglevering tarief 1: 1244.927 kWh</div>
<div class="line">1-0:1.7.0(00.342*kW)       ‚Üí Actueel verbruik: 342W</div>
<div class="line">0-1:24.2.3(241022130000W)(00456.789*m3)  ‚Üí Gas: 456.789 m¬≥ @ timestamp</div>
</div><!-- fragment --><p>De parser converteert deze fixed-point decimale waarden (6 decimalen precisie) direct naar integer milliwatt/milliwattuur representatie. Geen floating point conversies - de OBIS data is intern al integer fixed-point, dus door dit te behouden elimineren we FPU overhead volledig.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md99"></a>
UART Async API &amp; Timing</h2>
<p>De module gebruikt Zephyr's UART Async API met RX timeout detectie. Dit is cruciaal omdat DSMR telegrams variabel van lengte zijn (500-1500 bytes) en niet op een voorspelbare tijd eindigen. De UART events die we verwerken:</p>
<p><b>UART_RX_RDY</b>: Data beschikbaar in buffer</p><ul>
<li>Incrementeel bufferen van telegram data</li>
<li>CRC validatie nog niet mogelijk (telegram incomplete)</li>
</ul>
<p><b>UART_RX_DISABLED</b>: UART ontvangst gestopt</p><ul>
<li>Gebeurt na timeout (geen nieuwe data binnen timeout window)</li>
<li>Trigger voor "telegram compleet" ‚Üí start parsing</li>
<li>Dit is het primaire einde-detectie mechanisme</li>
</ul>
<p><b>UART_RX_STOPPED</b>: Buffer vol of andere stop conditie</p><ul>
<li>Fallback mechanisme</li>
<li>Trigger ook parsing (best effort)</li>
</ul>
<p><b>UART_RX_BUF_RELEASED</b>: Buffer teruggegeven door driver</p><ul>
<li>Huishoudelijke taak, geen actie vereist</li>
</ul>
<p>De timing is als volgt: DSMR stuurt om de ~1 seconde een telegram (duur: ~500-800ms voor volledig telegram). Na het telegram is er stilte. De UART RX timeout detecteert deze stilte en triggert <span class="tt">UART_RX_DISABLED</span> ‚Üí dit signaal betekent "telegram compleet, ga parsen".</p>
<p><b>Waarom timeout-based i.p.v. newline detectie?</b> DSMR telegrams eindigen met een CRC checksum, maar de structuur is: </p><div class="fragment"><div class="line">/ISK5\2M550T-1012</div>
<div class="line">...data...</div>
<div class="line">!xxxx  ‚Üê CRC in hex</div>
</div><!-- fragment --><p>De <span class="tt">!</span> marker zou je kunnen gebruiken, maar:</p><ul>
<li>Je moet toch de hele buffer bufferen (voor CRC check)</li>
<li>Timeout is betrouwbaarder (werkt ook bij corrupte <span class="tt">!</span> marker)</li>
<li>Zephyr UART Async timeout is hardware-assisted (efficient)</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md100"></a>
UART Timing Calculations - Fundamentals</h2>
<p>De timing parameters zijn niet arbitrair gekozen - ze zijn nauwkeurig berekend gebaseerd op UART hardware karakteristieken en DSMR specificaties. Hier is de volledige uitwerking:</p>
<p><b>UART Frame Timing (8N1 format)</b>:</p><ul>
<li>1 start bit + 8 data bits + 1 stop bit = <b>10 bits per byte</b></li>
<li>Bij 115200 bps: <span class="tt">115200 bits/s √∑ 10 bits/byte = 11520 bytes/s</span></li>
<li><b>Frame duration per byte</b>: <span class="tt">1,000,000 ¬µs √∑ 11520 = 86.8 ¬µs/byte</span></li>
</ul>
<p>Implementatie gebruikt macro die dit berekent: <span class="tt">1,000,000 / (BAUD_RATE / 10) + 1</span> ‚âà 87 ¬µs</p>
<p><b>Maximum Telegram Transmission Time</b>:</p>
<p>DSMR v5.0.2 specificatie: maximum telegram size = <b>8191 bytes</b> (ook nRF91 UART buffer limiet)</p>
<p>Basis berekening:</p><ul>
<li><span class="tt">8191 bytes √ó 87 ¬µs/byte = 712,617 ¬µs</span> (‚âà712.6 ms)</li>
</ul>
<p>Met 10% safety margin (clock drift, processing delays):</p><ul>
<li><span class="tt">712,617 ¬µs √ó 1.1 = 783,879 ¬µs</span> (‚âà783.9 ms)</li>
</ul>
<p>Timeout wordt berekend als: <span class="tt">MAX_SIZE √ó FRAME_DURATION √ó 1.1</span> ‚âà 784 ms</p>
<p><b>Inter-byte Timeout (UART RX timeout)</b>:</p>
<p>Dit is de timeout die detecteert wanneer een telegram compleet is (geen nieuwe data meer).</p>
<p>Berekening: 50% van maximum telegram time</p><ul>
<li><span class="tt">783,879 ¬µs √ó 0.5 = 391,940 ¬µs</span> (‚âà392 ms)</li>
</ul>
<p>Waarom 50%?</p><ul>
<li><b>Te kort</b>: False positives tijdens normale transmissie</li>
<li><b>Te lang</b>: Trage error detectie, vertraagde processing</li>
<li><b>392 ms</b>: Balans tussen betrouwbaarheid en responsiveness</li>
</ul>
<p>Deze timeout wordt gebruikt in uart_rx_enable() als inactivity timeout parameter.</p>
<p><b>Total Response Timeout</b>:</p>
<p>DSMR specificatie: P1 apparaat mag tot <b>10 seconden</b> wachten na Data Request voordat telegram start.</p>
<p>Totale timeout berekening:</p><ul>
<li>P1 response delay: <b>10,000 ms</b></li>
<li>Maximum telegram transmission: <b>783.9 ms</b></li>
<li><b>Totaal: 10,783.9 ms</b> (‚âà10.8 seconden)</li>
</ul>
<p>Timeout macro: <span class="tt">10000 + (MAX_TELEGRAM_TIMEOUT / 1000)</span> = 10,784 ms</p>
<p><b>Edge Case Scenarios</b>:</p>
<p><em>Scenario 1: Slow P1 Device</em></p><ul>
<li>t=0ms: Data Request pin asserted</li>
<li>t=9999ms: P1 start transmissie (net binnen 10s spec)</li>
<li>t=10783ms: Transmissie compleet (784ms later)</li>
<li><b>Result</b>: Success, binnen 10.8s timeout ‚úì</li>
</ul>
<p><em>Scenario 2: Maximum Length Telegram</em></p><ul>
<li>8191 bytes √ó 87 ¬µs/byte = 712.6ms base time</li>
<li>+10% margin = 783.9ms toegestaan</li>
<li>+P1 response delay = max 10s</li>
<li><b>Totaal budget</b>: 10.784s ‚úì</li>
</ul>
<p><em>Scenario 3: Inter-byte Timeout Trigger</em></p><ul>
<li>Bytes arriveren normaal (87 ¬µs intervals)</li>
<li>Gap &gt; 392ms gedetecteerd</li>
<li>Einde telegram aangenomen</li>
<li>UART_RX_DISABLED event ‚úì</li>
</ul>
<p><b>Watchdog Dependency</b>:</p>
<p>Kritiek: UART timeout moet korter zijn dan watchdog timeout! Build-time assertion valideert dit. Anders: watchdog reset tijdens valide telegram ontvangst ‚Üí reboot ‚Üí data loss.</p>
<p><b>Timing Parameters Samenvatting</b>:</p><ul>
<li><b>Baudrate</b>: 115200 bps (8N1)</li>
<li><b>Frame duration</b>: <b>87 ¬µs/byte</b> (exact UART timing)</li>
<li><b>Max telegram size</b>: <b>8191 bytes</b> (DSMR spec + nRF91 limiet)</li>
<li><b>P1 response delay</b>: <b>0-10s</b> (DSMR spec)</li>
<li><b>Inter-byte timeout</b>: <b>392 ms</b> (50% van max telegram)</li>
<li><b>Telegram timeout</b>: <b>784 ms</b> (max telegram + 10% margin)</li>
<li><b>Total timeout</b>: <b>10.8s</b> (P1 delay + telegram)</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md101"></a>
GPIO Data Request Pin &amp; Inverterende Buffer</h2>
<p>De P1 DSMR interface gebruikt een <b>Data Request</b> pin om telegrammen op te vragen. De hardware implementatie op Dinnis gebruikt een <b>inverterende buffer</b> tussen de nRF9161 GPIO en de P1 meter.</p>
<p><b>Hardware Signal Path</b>: </p><div class="fragment"><div class="line">nRF9161 GPIO (P0.26) ‚Üí [Inverterende Buffer] ‚Üí P1 Meter Data Request</div>
</div><!-- fragment --><p><b>DSMR P1 Specificatie Requirement</b>:</p>
<p>Volgens DSMR 5.0.2 specificatie verwacht de P1 poort een <b>HIGH (3.3V)</b> signaal om een data request te activeren:</p><ul>
<li><b>HIGH level</b>: Data request actief ‚Üí meter stuurt telegram</li>
<li><b>LOW level</b>: Idle state ‚Üí geen data request</li>
</ul>
<p><b>Inverterende Buffer Compensatie</b>:</p>
<p>De hardware bevat een inverterende buffer die het GPIO signaal omkeert voordat het naar de P1 meter gaat. Dit betekent dat de firmware moet compenseren voor deze inversie.</p>
<p><b>GPIO Configuratie: <span class="tt">GPIO_ACTIVE_LOW</span></b></p>
<p>In de device tree (<span class="tt">dinnis_nrf9161_ns.dts</span>): </p><div class="fragment"><div class="line">datarequest: data_request {</div>
<div class="line">    gpios = &lt;&amp;gpio0 26 GPIO_ACTIVE_LOW&gt;;  /* Inverting buffer compensation */</div>
<div class="line">    label = &quot;Data Request&quot;;</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>Signaal Flow met <span class="tt">GPIO_ACTIVE_LOW</span></b>:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Firmware API Call  </th><th class="markdownTableHeadNone">Logische State  </th><th class="markdownTableHeadNone">GPIO Pin (fysiek)  </th><th class="markdownTableHeadNone">Buffer Output  </th><th class="markdownTableHeadNone">P1 Meter Ziet  </th><th class="markdownTableHeadNone">Resultaat  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">gpio_pin_set_dt(..., 0)</span>  </td><td class="markdownTableBodyNone">Deasserted  </td><td class="markdownTableBodyNone"><b>HIGH (3.3V)</b>  </td><td class="markdownTableBodyNone"><b>LOW (0V)</b>  </td><td class="markdownTableBodyNone">LOW  </td><td class="markdownTableBodyNone">‚úÖ Idle (geen request)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">gpio_pin_set_dt(..., 1)</span>  </td><td class="markdownTableBodyNone">Asserted  </td><td class="markdownTableBodyNone"><b>LOW (0V)</b>  </td><td class="markdownTableBodyNone"><b>HIGH (3.3V)</b>  </td><td class="markdownTableBodyNone">HIGH  </td><td class="markdownTableBodyNone">‚úÖ Data request actief!  </td></tr>
</table>
<p><b>Waarom <span class="tt">GPIO_ACTIVE_LOW</span> Correct Is</b>:</p>
<ol type="1">
<li><b>P1 Specificatie</b>: P1 meter verwacht HIGH voor data request</li>
<li><b>Hardware Inversie</b>: Inverterende buffer draait signaal om</li>
<li><b>Firmware Compensatie</b>: <span class="tt">GPIO_ACTIVE_LOW</span> compenseert automatisch</li>
<li><b>Clean Code</b>: <span class="tt">gpio_pin_set_dt(&amp;pin, 1)</span> betekent logisch "assert request"</li>
</ol>
<p>De Zephyr GPIO API handelt de inversie automatisch af wanneer <span class="tt">GPIO_ACTIVE_LOW</span> is geconfigureerd. De firmware code blijft clean en leesbaar:</p>
<div class="fragment"><div class="line"><span class="comment">/* Initialize: deasserted state (no request) */</span></div>
<div class="line">gpio_pin_set_dt(&amp;<a class="code hl_variable" href="p__one_8c.html#a0e069e17511aca163f32accb3c5f625c">p_one_data_request</a>, 0);  </div>
<div class="line"><span class="comment">/* ‚Üí GPIO=HIGH ‚Üí Buffer=LOW ‚Üí P1=Idle ‚úì */</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Request telegram: asserted state */</span></div>
<div class="line">gpio_pin_set_dt(&amp;<a class="code hl_variable" href="p__one_8c.html#a0e069e17511aca163f32accb3c5f625c">p_one_data_request</a>, 1);  </div>
<div class="line"><span class="comment">/* ‚Üí GPIO=LOW ‚Üí Buffer=HIGH ‚Üí P1=Active ‚úì */</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Deassert after reception */</span></div>
<div class="line">gpio_pin_set_dt(&amp;<a class="code hl_variable" href="p__one_8c.html#a0e069e17511aca163f32accb3c5f625c">p_one_data_request</a>, 0);  </div>
<div class="line"><span class="comment">/* ‚Üí GPIO=HIGH ‚Üí Buffer=LOW ‚Üí P1=Idle ‚úì */</span></div>
<div class="ttc" id="ap__one_8c_html_a0e069e17511aca163f32accb3c5f625c"><div class="ttname"><a href="p__one_8c.html#a0e069e17511aca163f32accb3c5f625c">p_one_data_request</a></div><div class="ttdeci">const struct gpio_dt_spec p_one_data_request</div><div class="ttdef"><b>Definition</b> <a href="p__one_8c_source.html#l00218">p_one.c:218</a></div></div>
</div><!-- fragment --><p><b>Alternatief zonder <span class="tt">GPIO_ACTIVE_LOW</span></b>:</p>
<p>Als de pin <span class="tt">GPIO_ACTIVE_HIGH</span> was geconfigureerd, zou de code verwarrend worden: </p><div class="fragment"><div class="line">gpio_pin_set_dt(&amp;pin, 1);  <span class="comment">/* Set HIGH ‚Üí Buffer inverts ‚Üí P1 sees LOW ‚Üí WRONG! */</span></div>
<div class="line">gpio_pin_set_dt(&amp;pin, 0);  <span class="comment">/* Set LOW ‚Üí Buffer inverts ‚Üí P1 sees HIGH ‚Üí Request?? */</span></div>
</div><!-- fragment --><p>Met <span class="tt">GPIO_ACTIVE_LOW</span> blijft de code intu√Øtief: <span class="tt">1</span> = "assert request", <span class="tt">0</span> = "deassert request", ongeacht de hardware inversie.</p>
<p><b>Hardware Design Rationale</b>:</p>
<p>De inverterende buffer dient mogelijk voor:</p><ul>
<li><b>Level shifting</b> tussen verschillende voltage domains</li>
<li><b>Signal conditioning</b> voor betere EMC eigenschappen</li>
<li><b>ESD protection</b> met ge√Øntegreerde clamp circuits</li>
<li><b>Current buffering</b> om GPIO pin te beschermen</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md102"></a>
OBIS Parsing &amp; Data Conversie</h2>
<p>Elk OBIS veld wordt geparsed door een dedicated parser functie. De parsers zijn type-specifiek:</p>
<p><b>Fixed-point numerieke waarden</b>:</p>
<p>Voorbeeld OBIS field: <span class="tt">1-0:1.8.1(002841.463*kWh)</span> bevat fixed-point waarde met 6 decimalen precisie.</p>
<p>Parser extractie proces:</p><ol type="1">
<li>Vind numerieke waarde tussen haakjes: "002841.463"</li>
<li>Parse naar integer door decimale punt te verwijderen: 2841463</li>
<li>Converteer eenheid: kWh ‚Üí Wh (√ó 1000) = 2841463 Wh</li>
<li>Opslag als int32_t (4 bytes)</li>
</ol>
<p>De conversie: OBIS geeft kWh, wij willen Wh integer. Dus <span class="tt">2841.463 kWh * 1000 = 2841463 Wh</span>. Bij vermogen: <span class="tt">0.342 kW * 1000 = 342W</span>. Alles blijft integer, geen floating point.</p>
<p><b>Timestamps</b>:</p>
<p>P1 DSMR meters hebben hun <b>eigen klok</b> die gesynchroniseerd wordt door de DSO (Distribution System Operator).</p>
<p><b>OBIS 0-0:1.0.0 - Telegram Timestamp</b>:</p><ul>
<li>Formaat: <span class="tt">YYMMDDHHmmssX</span> (bijv. <span class="tt">241022130000W</span>)</li>
<li>Geeft tijd van <b>dit telegram</b> (lokale tijd met DST)</li>
<li>Suffix: <span class="tt">W</span>=winter, <span class="tt">S</span>=zomer (DST indicator)</li>
<li><b>Nauwkeurigheid</b>: Beter dan device RTC (DSO synchroniseert via netwerk)</li>
</ul>
<p><b>Parser extractie proces</b>:</p><ol type="1">
<li>Extract timestamp string: "241022130000"</li>
<li>Parse componenten: Jaar=24, Maand=10, Dag=22, Uur=13, Min=00, Sec=00</li>
<li>Converteer naar Unix epoch seconds via <span class="tt">timeutil_timegm64()</span> (Zephyr time utilities)</li>
<li><b>Normalisatie</b>: Pas DST-indicator toe (zie hieronder)</li>
<li>Opslag intern: <span class="tt">timestamp_epoch_localtime_s</span> (uint64_t, <b>seconds</b>)</li>
<li>Output conversie: √ó 1000 ‚Üí <span class="tt">timestamp_epoch_ms</span> (int64_t, <b>milliseconds</b>)</li>
</ol>
<p><b>Timestamp Normalisatie</b>:</p>
<p>De P1-meter levert lokale tijd met een DST-indicator ('S'/'W'). De firmware normaliseert deze naar een consistent formaat:</p>
<ul>
<li><b>Zomertijd ('S')</b>: Trek 1 uur (3600 seconden) af</li>
<li><b>Wintertijd ('W')</b>: Geen aanpassing</li>
</ul>
<p><b>Resultaat</b>: Output timestamp is altijd genormaliseerd naar "wintertijd-niveau". De firmware heeft geen kennis van tijdzones - verdere conversie naar UTC is de verantwoordelijkheid van de server</p>
<p><b>Field Naming Convention</b>:</p><ul>
<li><span class="tt">timestamp_epoch_localtime_s</span>: Internal storage (seconds, normalized local time)</li>
<li><span class="tt">timestamp_epoch_ms</span>: Output to message queue (milliseconds, normalized local time)</li>
<li><span class="tt">_epoch_s</span> / <span class="tt">_epoch_ms</span> suffix indicates unit AND time base (vs <span class="tt">uptime_ms</span> for system uptime)</li>
<li><b>‚ö†Ô∏è "epoch" in naam impliceert NIET UTC</b> - dit is genormaliseerde lokale tijd</li>
</ul>
<p><b>Peak Timestamps</b> (power statistics):</p><ul>
<li>Stored: <span class="tt">consumed_max_timestamp_epoch_s</span>, <span class="tt">delivered_max_timestamp_epoch_s</span> (int64_t, <b>seconds</b>)</li>
<li>Output: <span class="tt">power_consumed_max_timestamp_epoch_ms</span>, <span class="tt">power_delivered_max_timestamp_epoch_ms</span> (√ó 1000 ‚Üí <b>milliseconds</b>)</li>
<li><b>Rationale</b>: Peak occurred at specific meter time, tracked across rolling window</li>
</ul>
<p><b>Gas Timestamps</b> (M-Bus devices): Voorbeeld OBIS field: <span class="tt">0-1:24.2.3(241022130000W)(00456.789*m3)</span> bevat timestamp <b>EN</b> gas waarde.</p><ul>
<li>Gas updates elk <b>uur</b> (niet elke seconde zoals elektriciteit)</li>
<li>Timestamp geeft tijdstip van <b>deze gas meting</b></li>
<li>Parser: Extractie identiek aan telegram timestamp (YYMMDDHHmmssX formaat)</li>
<li><b>Normalisatie</b>: Gas timestamps volgen dezelfde DST normalisatie als telegram timestamps</li>
</ul>
<p><b>Strings</b>:</p><ul>
<li>Gebruikt voor versie nummers, meter ID's (future use)</li>
<li>Direct string copy zonder conversie</li>
</ul>
<p>Alle parsers valideren input via sanity check: minimaal 10 karakters, bevat <span class="tt">(</span>, <span class="tt">*</span>, <span class="tt">)</span>. Dit voorkomt crashes op corrupte data.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md103"></a>
Rolling Statistics &amp; Sampling</h2>
<p>Hier wordt het interessant. We willen niet elke seconde data naar de cloud sturen (te veel data verkeer, kosten, energie). In plaats daarvan verzamelen we samples over een periode en berekenen statistieken.</p>
<p><b>Sampling flow</b> (voorbeeld met 30s interval): </p><div class="fragment"><div class="line">t=0s:   ACQ_TRIGGER ‚Üí Meet vermogen ‚Üí Sample 1 (bijv. 342W verbruik)</div>
<div class="line">t=30s:  ACQ_TRIGGER ‚Üí Meet vermogen ‚Üí Sample 2 (bijv. 520W verbruik)</div>
<div class="line">t=60s:  ACQ_TRIGGER ‚Üí Meet vermogen ‚Üí Sample 3 (bijv. 410W verbruik)</div>
<div class="line">...</div>
<div class="line">t=570s: ACQ_TRIGGER ‚Üí Meet vermogen ‚Üí Sample 20 (bijv. 380W verbruik)</div>
<div class="line">t=600s: PUBLISH ‚Üí Bereken stats ‚Üí Publiceer ‚Üí Reset</div>
</div><!-- fragment --><p>Per 20 samples (10 minuten bij 30s interval) berekenen we:</p><ul>
<li><b>Average</b>: Gemiddelde vermogen over periode (som / count)</li>
<li><b>Maximum</b>: Hoogste piek + timestamp (voor peak shaving analyse)</li>
<li><b>Minimum</b>: Laagste waarde (baseline verbruik)</li>
</ul>
<p><b>Waarom separate consumed vs delivered stats?</b></p>
<p>Dit is een cruciale design keuze. Alternatief was "net power" (consumed - delivered), maar dat maskeert informatie:</p>
<p><b>Scenario:</b> Om 12:00 verbruik je 1.5kW (huishouden) terwijl zonnepanelen 3kW produceren.</p><ul>
<li><b>Net power</b>: -1.5kW (teruglevering) <br  />
 ‚ùó Je ziet niet dat je 1.5kW verbruikt ‚ùó Je ziet niet dat je 3kW produceert</li>
<li><b>Separate stats</b>: consumed=1.5kW, delivered=3kW <br  />
 ‚úÖ Volledig inzicht in gedrag ‚úÖ DEV optimalisatie mogelijk (meer verbruiken om teruglevering te verminderen) ‚úÖ Peak shaving mogelijk (piekverbruik identificeren, ongeacht opwek)</li>
</ul>
<p><b>Use case - Peak Shaving:</b> <br  />
 Stats tonen <span class="tt">power_consumed_max_w = 4.5kW @ 08:00</span>. Analyse: koffie (1.2kW) + oven (2.5kW) + wasmachine (0.8kW) = 4.5kW piek. Actie: verschuif wasmachine naar 10:00 ‚Üí nieuwe max = 3.7kW ‚Üí lagere netaansluitkosten.</p>
<p><b>Use case - DEV Optimalisatie:</b> <br  />
 Stats tonen <span class="tt">delivered_avg = 3.5kW</span> van 12:00-14:00. Dit betekent teveel teruglevering (verlies bij lage terugleveringsvergoeding). Actie: start wasmachine + vaatwasser om 13:00 (tijdens zonnige uren) ‚Üí vermindert teruglevering, verhoogt zelfverbruik.</p>
<p>De statistics worden bijgehouden met aparte accumulators voor consumed en delivered.</p>
<p><b>Bij elke ACQ_TRIGGER</b> (nieuwe sample):</p><ul>
<li>Update running sum (voor average berekening)</li>
<li>Check en update max waarde (+ timestamp opslaan)</li>
<li>Check en update min waarde</li>
<li>Increment sample counter</li>
</ul>
<p><b>Bij PUBLISH trigger</b> (statistieken publiceren):</p><ul>
<li>Bereken average: <span class="tt">sum / sample_count</span></li>
<li>Neem max waarde + timestamp</li>
<li>Neem min waarde</li>
<li>Publish naar <a class="el" href="structp__one__msg.html" title="P_ONE module message structure.">p_one_msg</a></li>
<li>Reset alle rolling stats voor nieuwe periode</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md104"></a>
Gas Meting Acquisitie</h2>
<p>Gas is speciaal: DSMR meters updaten gas slechts elk uur (niet elke seconde zoals elektriciteit). Het OBIS veld bevat zowel de gas waarde als een timestamp.</p>
<p>Voorbeeld OBIS gas field: <span class="tt">0-1:24.2.3(241022130000W)(00456.789*m3)</span> bevat timestamp EN gas meterstand.</p>
<p>We extracten:</p><ul>
<li><span class="tt">gas_consumed_m3</span>: Cumulatieve meterstand (int32_t, in milli-m¬≥)</li>
<li>Gas timestamp: Wanneer deze meting gedaan is</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md105"></a>
ZBUS Integratie</h1>
<p>De module communiceert via ZBUS channels:</p>
<p><b>Subscribed Channels:</b></p><ul>
<li><span class="tt">DATA_ACQUISITION_TRIGGER_CHAN</span> (van timing module) - Elke 30s trigger om P1 data te lezen</li>
<li><span class="tt">DATA_PUBLISH_REQUEST_CHAN</span> (van timing module) - Elke 600s trigger om statistieken te publiceren</li>
</ul>
<p><b>Published Channels:</b></p><ul>
<li><span class="tt">P_ONE_CHAN</span> (naar message queue) - Gepubliceerde statistieken na elke publish cycle</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md106"></a>
ACQ_TRIGGER Flow</h2>
<p>Bij ontvangst van <span class="tt">DATA_ACQUISITION_TRIGGER_CHAN</span>:</p><ol type="1">
<li>Assert Data Request GPIO pin ‚Üí meter start telegram verzenden</li>
<li>Enable UART RX met timeout</li>
<li>Wacht op UART callback (<span class="tt">UART_RX_DISABLED</span> event bij timeout)</li>
<li>Parse OBIS data uit ontvangen telegram</li>
<li>Converteer naar integers (fixed-point ‚Üí milliwatt)</li>
<li>Update rolling statistics (avg/max/min accumulators)</li>
<li>Deassert Data Request pin</li>
<li>Feed watchdog</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="autotoc_md107"></a>
PUBLISH Flow</h2>
<p>Bij ontvangst van <span class="tt">DATA_PUBLISH_REQUEST_CHAN</span>:</p><ol type="1">
<li><b>Validatie</b>: Controleer of er geldige samples zijn verzameld (<span class="tt">p1_stats.sample_count &gt; 0</span>).<ul>
<li><b>Indien nee</b>: Log een foutmelding en sla de publicatie over. Dit voorkomt het verzenden van lege of verouderde data. De statistieken worden wel gereset.</li>
<li><b>Indien ja</b>: Ga door naar de volgende stap.</li>
</ul>
</li>
<li>Bereken finale statistieken uit accumulators (avg = sum/count).</li>
<li>Vul <span class="tt"><a class="el" href="structp__one__msg.html" title="P_ONE module message structure.">p_one_msg</a></span> struct:<ul>
<li>Timestamp (huidige tijd in UNIX ms)</li>
<li>Energie totalen (4 velden: consumed/delivered √ó tarief1/2, in Wh)</li>
<li>Gas totaal + gas timestamp (in <b>dm¬≥</b>, oftewel liters)</li>
<li>Vermogen statistieken consumed (avg/max/min in W + timestamps)</li>
<li>Vermogen statistieken delivered (avg/max/min in W + timestamps)</li>
</ul>
</li>
<li>Publiceer naar <span class="tt">P_ONE_CHAN</span> ‚Üí message queue ontvangt dit.</li>
<li>Reset alle rolling stats voor nieuwe periode.</li>
<li>Feed watchdog.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="autotoc_md108"></a>
Architectuur</h1>
<p>De P1 module gebruikt <b>GEEN state machine</b>. In plaats daarvan werkt de module volledig <b>event-driven</b> via twee mechanismen:</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md109"></a>
1. UART Callbacks (Asynchrone Data Ontvangst)</h2>
<p>De module registreert een UART callback handler die interrupt-driven UART events verwerkt:</p>
<ul>
<li><b><span class="tt">UART_RX_RDY</span></b>: Data ontvangen, kopieer naar buffer</li>
<li><b><span class="tt">UART_RX_DISABLED</span></b>: RX timeout of error, start parsing van ontvangen data</li>
<li><b><span class="tt">UART_RX_STOPPED</span></b>: Buffer vol (8191 bytes), forceer parsing</li>
</ul>
<p>De UART is geconfigureerd met:</p><ul>
<li><b>Baudrate</b>: 115200 (DSMR spec)</li>
<li><b>RX timeout</b>: 392ms (berekend: 4.5√ó max telegram tijd)</li>
<li><b>Buffer size</b>: 8191 bytes (nRF91 UART limit)</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md110"></a>
2. ZBUS Message Handling (Periodieke Triggers)</h2>
<p>De thread loop luistert naar ZBUS events met <span class="tt">zbus_sub_wait()</span>:</p>
<p><b><span class="tt">DATA_ACQUISITION_TRIGGER_CHAN</span></b> (elke 30s via timing module):</p><ol type="1">
<li>Assert Data Request pin (HIGH)</li>
<li>Enable UART RX</li>
<li>Wacht op callback (telegram ontvangst)</li>
<li>Parse telegram ‚Üí update rolling statistics</li>
<li>Deassert Data Request pin (LOW)</li>
<li>Feed watchdog</li>
</ol>
<p><b><span class="tt">DATA_PUBLISH_REQUEST_CHAN</span></b> (elke 600s via timing module):</p><ol type="1">
<li>Publiceer statistieken naar <span class="tt">P_ONE_CHAN</span></li>
<li>Reset alle rolling stats (avg/min/max)</li>
<li>Feed watchdog</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="autotoc_md111"></a>
Thread Loop Structuur</h2>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (1) {</div>
<div class="line">    zbus_sub_wait(&amp;chan, msg_buf, timeout);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (chan == DATA_ACQUISITION_TRIGGER_CHAN) {</div>
<div class="line">        acquire_p1_data();  <span class="comment">// Trigger UART RX</span></div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (chan == DATA_PUBLISH_REQUEST_CHAN) {</div>
<div class="line">        publish_statistics();  <span class="comment">// Publiceer + reset</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    task_wdt_feed(task_wdt_id);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Robuustheid</b>: De module heeft geen expliciete "sync" state. Bij boot kan de UART midden in een telegram starten, maar de CRC check zorgt ervoor dat corrupt data wordt verworpen. Het eerste <b>valide</b> telegram (na boot of na error) synchroniseert automatisch.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md112"></a>
Technische Diepgang</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md113"></a>
Waarom Integer Fixed-Point?</h2>
<p><b>Probleem</b>: DSMR OBIS data is fixed-point decimaal (6 cijfers precisie). Embedded systeem heeft beperkt RAM.</p>
<p><b>Design Keuze</b>: Direct string‚Üíint32_t parsing in plaats van floating point conversie.</p>
<p><b>Rationale</b>: </p><div class="fragment"><div class="line">OBIS format: &quot;002841.463*kWh&quot;</div>
<div class="line">‚Üí Parse direct naar int32_t (2841463 mWh)</div>
<div class="line">‚Üí Geen atof(), geen FPU nodig</div>
</div><!-- fragment --><p><b>Voordelen</b>:</p><ul>
<li>Elimineer FPU overhead (Cortex-M33 heeft geen hardware FPU)</li>
<li>Halveer geheugen per veld (4 bytes vs 8 bytes)</li>
<li>Behoud precisie (6 decimalen = 1 ¬µWh nauwkeurigheid, voldoende voor kWh metingen)</li>
</ul>
<p><b>Implementatie</b>: <span class="tt">obis_fixed_point_to_milli()</span> gebruikt string manipulatie om decimale punt te verwijderen.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md114"></a>
CRC16 Validatie</h2>
<p>DSMR telegrams eindigen met CRC16 checksum: </p><div class="fragment"><div class="line">/ISK5\2M550T-1012</div>
<div class="line"> </div>
<div class="line">1-0:1.8.1(002841.463*kWh)</div>
<div class="line">...</div>
<div class="line">!F3A2  ‚Üê CRC16 in hex</div>
</div><!-- fragment --><p>De CRC wordt berekend over alles vanaf <span class="tt">/</span> tot <span class="tt">!</span> (exclusief). We implementeren CRC16 volgens DSMR spec (polynomial 0xA001, init 0x0000).</p>
<p>Validatie flow:</p><ol type="1">
<li>Parse CRC waarde na <span class="tt">!</span> (hex string ‚Üí int)</li>
<li>Bereken CRC over buffer (0 tot <span class="tt">!</span> positie)</li>
<li>Vergelijk: <span class="tt">if (calculated != parsed) ‚Üí ERROR</span></li>
</ol>
<p>Als CRC faalt ‚Üí discard telegram, wacht op volgende. Geen retry logic (meter stuurt elk seconde nieuw telegram anyway).</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md115"></a>
Edge Cases &amp; Robuustheid</h2>
<p><b>Scenario 1: UART Error tijdens ontvangst</b> <br  />
 ‚Üí Event: <span class="tt">UART_RX_DISABLED</span> met error code <br  />
 ‚Üí Actie: Log error, discard buffer, restart RX <br  />
 ‚Üí Impact: Skip √©√©n telegram (1s data loss), auto-recover</p>
<p><b>Scenario 2: Corrupt telegram (CRC fail)</b> <br  />
 ‚Üí Detectie: CRC mismatch <br  />
 ‚Üí Actie: Log warning, discard, wacht op volgende <br  />
 ‚Üí Impact: Skip √©√©n sample (bij 20 samples/periode is 1 loss acceptable)</p>
<p><b>Scenario 3: OBIS veld niet gevonden</b> <br  />
 ‚Üí Detectie: Parser returnt error <br  />
 ‚Üí Actie: Gebruik vorige waarde (stale data) of 0 (first run) <br  />
 ‚Üí Impact: Graceful degradation (liever incomplete data dan crash)</p>
<p><b>Scenario 4: Buffer overflow (telegram &gt; 8191 bytes)</b> <br  />
 ‚Üí Event: <span class="tt">UART_RX_STOPPED</span> <br  />
 ‚Üí Actie: Parse wat we hebben (best-effort), log warning <br  />
 ‚Üí Impact: Mogelijk incomplete data, maar geen crash</p>
<p><b>Scenario 5: Gas timestamp niet ge√ºpdatet</b> <br  />
 ‚Üí Detectie: Zelfde timestamp als vorige sample <br  />
 ‚Üí Actie: Gebruik cached waarde, skip statistics update <br  />
 ‚Üí Impact: Gas stats blijven stabiel (gas update is elk uur, niet elk sample)</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md116"></a>
Timing &amp; Watchdog</h2>
<p>De module registreert zich bij Task Watchdog. Feed interval wordt berekend op basis van Kconfig:</p>
<div class="fragment"><div class="line">Feed interval = WATCHDOG_TIMEOUT - MSG_PROCESSING_TIME</div>
</div><!-- fragment --><p><b>Rationale</b>:</p><ul>
<li><span class="tt">WATCHDOG_TIMEOUT</span>: Maximaal toegestane tijd tussen feed calls</li>
<li><span class="tt">MSG_PROCESSING_TIME</span>: Worst-case tijd voor UART RX + parsing</li>
<li>Thread feed na elke acquisitie EN na elke publish</li>
</ul>
<p>Build-time assertion valideert: <span class="tt">WATCHDOG_TIMEOUT &gt; MSG_PROCESSING_TIME + UART_TOTAL_TIMEOUT</span></p>
<p>Dit voorkomt watchdog reset tijdens valide UART operatie. De UART timeout (10.8s) moet ruim binnen watchdog budget vallen.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md117"></a>
Configuratie</h1>
<p>Kconfig opties (prefix: <span class="tt">CONFIG_APP_P_ONE_MODULE_</span>):</p>
<ul>
<li><span class="tt">LOG_LEVEL</span>: Logging niveau (default: zie prj.conf)</li>
<li><span class="tt">WATCHDOG_TIMEOUT_SECONDS</span>: Watchdog timeout in seconden</li>
<li><span class="tt">MSG_PROCESSING_TIME_SECONDS</span>: Maximale message processing tijd</li>
<li><span class="tt">THREAD_STACK_SIZE</span>: Thread stack size in bytes</li>
</ul>
<p><b>Opmerking</b>: De module heeft geen runtime configuratie via Settings subsystem. Alle configuratie gebeurt via Kconfig tijdens compile-time. UART parameters (baudrate 115200, device uart3) zijn hardcoded volgens DSMR spec.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md118"></a>
Data Output</h1>
<p>De <span class="tt"><a class="el" href="structp__one__msg.html" title="P_ONE module message structure.">p_one_msg</a></span> struct bevat:</p>
<p><b>Timestamp</b>: Publicatie tijdstip (UNIX ms)</p>
<p><b>Energie (cumulatief, in Wh):</b></p><ul>
<li><span class="tt">energy_consumed_wh_tariff1/2</span>: Totaal verbruik van net</li>
<li><span class="tt">energy_delivered_wh_tariff1/2</span>: Totaal teruglevering naar net</li>
</ul>
<p><b>Gas (cumulatief + timestamp):</b></p><ul>
<li><span class="tt">gas_consumed_dm3</span>: Totaal gasverbruik (in <b>dm¬≥</b>, oftewel liters)</li>
<li>Gas timestamp embedded in OBIS data (voor staleness detectie)</li>
</ul>
<p><b>Vermogen statistieken (over sample periode, in W):</b></p>
<p><em>Consumed (van net):</em></p><ul>
<li><span class="tt">power_consumed_avg_w</span>: Gemiddeld verbruik</li>
<li><span class="tt">power_consumed_max_w</span>: Piek verbruik <br  />
</li>
<li><span class="tt">power_consumed_max_timestamp</span>: Wanneer piek optrad</li>
<li><span class="tt">power_consumed_min_w</span>: Baseline verbruik</li>
</ul>
<p><em>Delivered (naar net):</em></p><ul>
<li><span class="tt">power_delivered_avg_w</span>: Gemiddelde teruglevering</li>
<li><span class="tt">power_delivered_max_w</span>: Piek teruglevering</li>
<li><span class="tt">power_delivered_max_timestamp</span>: Wanneer piek optrad <br  />
</li>
<li><span class="tt">power_delivered_min_w</span>: Minimum teruglevering</li>
</ul>
<p>Deze data wordt geconsumeerd door Message Queue module (combineert met pulse data) en uiteindelijk ge√ºpload naar nRF Cloud voor analyse en visualisatie.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md120"></a>
üìê Appendix A: UART Timing Analyse</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md121"></a>
Overzicht</h2>
<p>De P1 DSMR module implementeert een robuuste multi-layer timing strategie voor data acquisitie van slimme meters. Deze sectie legt exact uit hoe alle timing values berekend zijn en waarom elk timeout cruciaal is voor betrouwbare operatie.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md122"></a>
UART Frame Timing Fundamentals</h2>
<p><b>Basic UART Frame Structure (8N1)</b>:</p><ul>
<li>1 start bit + 8 data bits + 1 stop bit = <b>10 bits per byte</b></li>
<li>At 115200 bps: <b>115200 bits/second √∑ 10 bits/byte = 11520 bytes/second</b></li>
<li><b>Frame duration per byte</b>: 1,000,000 ¬µs √∑ 11520 bytes/s = <b>86.8 ¬µs/byte</b></li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Code implementation:</span></div>
<div class="line"><span class="preprocessor">#define P_ONE_UART_FRAME_DURATION_USEC \</span></div>
<div class="line"><span class="preprocessor">    (unsigned long)(1000 * 1000 / (P_ONE_UART_BAUD_RATE / 10) + 1)</span></div>
<div class="line"><span class="comment">// Result: (1,000,000 / (115200 / 10)) + 1 = 86.8 + 1 = ~87 ¬µs</span></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md123"></a>
Critical Timing Calculations</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md124"></a>
1. Maximum Telegram Transmission Time</h3>
<p><b>DSMR v5.0.2 specifies maximum telegram size: 8191 bytes</b></p>
<p><b>Base calculation</b>:</p><ul>
<li>8191 bytes √ó 87 ¬µs/byte = <b>712,617 ¬µs</b> (‚âà712.6 ms)</li>
</ul>
<p><b>With 10% safety margin</b> (for clock drift, processing delays):</p><ul>
<li>712,617 ¬µs √ó 1.1 = <b>783,879 ¬µs</b> (‚âà783.9 ms)</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Code implementation:</span></div>
<div class="line"><span class="preprocessor">#define P_ONE_UART_MAX_TELEGRAM_TIMEOUT_USEC \</span></div>
<div class="line"><span class="preprocessor">    (P_ONE_UART_MAX_TELEGRAM_SIZE * P_ONE_UART_FRAME_DURATION_USEC * 1.1)</span></div>
<div class="line"><span class="comment">// Result: 8191 √ó 87 √ó 1.1 = ~783,879 ¬µs</span></div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md125"></a>
2. UART RX Timeout (Inter-byte timeout)</h3>
<p><b>Purpose</b>: Detect end of telegram when no more data arrives</p>
<p><b>Calculation</b>: 50% of maximum telegram time</p><ul>
<li>783,879 ¬µs √ó 0.5 = <b>391,940 ¬µs</b> (‚âà392 ms)</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Used in uart_rx_enable():</span></div>
<div class="line">uart_rx_enable(<a class="code hl_variable" href="p__one_8c.html#a660f23134aaae43c9ff2c6096fa59342">uart_dev</a>, <a class="code hl_variable" href="p__one_8c.html#a225d537524678c83d06f5fbbbbc3588f">p_one_uart_rx_buf</a>, <a class="code hl_define" href="p__one_8c.html#a1f25fe45d891de244a8135ae02fc9265">UART_RX_BUF_SIZE</a>,</div>
<div class="line">               <a class="code hl_define" href="p__one_8c.html#ad20309c579792abe59be2c8c7bb0fd68">P_ONE_UART_MAX_TELEGRAM_TIMEOUT_USEC</a> * 0.5);</div>
<div class="ttc" id="ap__one_8c_html_a1f25fe45d891de244a8135ae02fc9265"><div class="ttname"><a href="p__one_8c.html#a1f25fe45d891de244a8135ae02fc9265">UART_RX_BUF_SIZE</a></div><div class="ttdeci">#define UART_RX_BUF_SIZE</div><div class="ttdef"><b>Definition</b> <a href="p__one_8c_source.html#l00071">p_one.c:71</a></div></div>
<div class="ttc" id="ap__one_8c_html_a225d537524678c83d06f5fbbbbc3588f"><div class="ttname"><a href="p__one_8c.html#a225d537524678c83d06f5fbbbbc3588f">p_one_uart_rx_buf</a></div><div class="ttdeci">static uint8_t p_one_uart_rx_buf[(8191)]</div><div class="ttdef"><b>Definition</b> <a href="p__one_8c_source.html#l00225">p_one.c:225</a></div></div>
<div class="ttc" id="ap__one_8c_html_a660f23134aaae43c9ff2c6096fa59342"><div class="ttname"><a href="p__one_8c.html#a660f23134aaae43c9ff2c6096fa59342">uart_dev</a></div><div class="ttdeci">static const struct device * uart_dev</div><div class="ttdef"><b>Definition</b> <a href="p__one_8c_source.html#l00222">p_one.c:222</a></div></div>
<div class="ttc" id="ap__one_8c_html_ad20309c579792abe59be2c8c7bb0fd68"><div class="ttname"><a href="p__one_8c.html#ad20309c579792abe59be2c8c7bb0fd68">P_ONE_UART_MAX_TELEGRAM_TIMEOUT_USEC</a></div><div class="ttdeci">#define P_ONE_UART_MAX_TELEGRAM_TIMEOUT_USEC</div><div class="ttdef"><b>Definition</b> <a href="p__one_8c_source.html#l00049">p_one.c:49</a></div></div>
</div><!-- fragment --><p><b>Why 50%?</b> This ensures the timeout is:</p><ul>
<li>Long enough to avoid false triggers during normal transmission</li>
<li>Short enough to quickly detect end-of-telegram</li>
<li>Covers worst-case inter-byte delays in P1 devices</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md126"></a>
3. Total Response Timeout</h3>
<p><b>DSMR specification</b>: P1 device may take up to <b>10 seconds</b> to respond after Data Request</p>
<p><b>Total timeout calculation</b>:</p><ul>
<li>P1 response delay: <b>10,000 ms</b></li>
<li>Maximum telegram time: <b>783.9 ms</b></li>
<li><b>Total: 10,783.9 ms</b> (‚âà10.8 seconds)</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#define P_ONE_DATA_REQUEST_RESPONSE_TIMEOUT_MSEC \</span></div>
<div class="line"><span class="preprocessor">    (10000 + P_ONE_UART_MAX_TELEGRAM_TIMEOUT_USEC / 1000)</span></div>
<div class="line"><span class="comment">// Result: 10000 + 783.9 = 10,783.9 ms</span></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md127"></a>
Why These Specific Timeouts Matter</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md128"></a>
Frame-Level Timing (87 ¬µs)</h3>
<ul>
<li><b>Too short</b>: Miss bytes due to processing overhead</li>
<li><b>Too long</b>: Inefficient, delays error detection</li>
<li><b>87 ¬µs</b>: Matches exact UART hardware timing</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md129"></a>
Inter-byte Timeout (392 ms)</h3>
<ul>
<li><b>Too short</b>: False end-of-telegram detection during valid transmission</li>
<li><b>Too long</b>: Slow error recovery, delayed processing</li>
<li><b>392 ms</b>: Balances reliability vs responsiveness</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md130"></a>
Telegram Timeout (784 ms)</h3>
<ul>
<li><b>Too short</b>: Truncate valid long telegrams</li>
<li><b>Too long</b>: Slow detection of stuck/corrupted transmission</li>
<li><b>784 ms</b>: Covers maximum DSMR telegram + safety margin</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md131"></a>
Response Timeout (10.8s)</h3>
<ul>
<li><b>Too short</b>: Fail on slow P1 devices (spec allows 10s)</li>
<li><b>Too long</b>: Slow error recovery, high power consumption</li>
<li><b>10.8s</b>: Covers worst-case P1 response + full telegram</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md132"></a>
Edge Case Scenarios</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md133"></a>
Scenario 1: Slow P1 Device Response</h3>
<div class="fragment"><div class="line">Time 0ms:    Assert Data Request</div>
<div class="line">Time 9999ms: P1 device starts transmission (just within 10s spec)</div>
<div class="line">Time 10783ms: Transmission complete (784ms later)</div>
<div class="line">Result:      Success - within 10.8s timeout</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md134"></a>
Scenario 2: Maximum Length Telegram</h3>
<div class="fragment"><div class="line">8191 bytes √ó 87 ¬µs/byte = 712.6ms base transmission time</div>
<div class="line">+ 10% margin = 783.9ms total allowed</div>
<div class="line">+ P1 response delay = up to 10 seconds</div>
<div class="line">= Total budget: 10.784 seconds</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md135"></a>
Scenario 3: Inter-byte Timeout Trigger</h3>
<div class="fragment"><div class="line">Bytes arriving normally at 87 ¬µs intervals</div>
<div class="line">Gap &gt; 392ms detected ‚Üí End of telegram assumed</div>
<div class="line">UART_RX_DISABLED event triggered</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md136"></a>
Critical Dependencies</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md137"></a>
Watchdog Relationship</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="p__one_8c.html#a3f48fcbc19fe59b24bda25731cea5c00">BUILD_ASSERT</a>((<a class="code hl_define" href="p__one_8c.html#ad20309c579792abe59be2c8c7bb0fd68">P_ONE_UART_MAX_TELEGRAM_TIMEOUT_USEC</a> / 1000) &lt;</div>
<div class="line">             (CONFIG_APP_P_ONE_MODULE_WATCHDOG_TIMEOUT_SECONDS * 1000),</div>
<div class="line">             <span class="stringliteral">&quot;UART timeout must be less than watchdog timeout&quot;</span>);</div>
<div class="ttc" id="ap__one_8c_html_a3f48fcbc19fe59b24bda25731cea5c00"><div class="ttname"><a href="p__one_8c.html#a3f48fcbc19fe59b24bda25731cea5c00">BUILD_ASSERT</a></div><div class="ttdeci">BUILD_ASSERT(((8191 *(unsigned long)(1000 *1000/(DT_PROP(DT_NODELABEL(uart3), current_speed)/10)+1) *1.1)/1000)&lt;(CONFIG_APP_P_ONE_MODULE_WATCHDOG_TIMEOUT_SECONDS *1000), &quot;UART timeout must be less than watchdog timeout&quot;)</div></div>
</div><!-- fragment --><p> <b>Why</b>: Prevents watchdog reset during valid telegram reception</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md138"></a>
Buffer Size Constraint</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#define UART_MAX_BUF_SIZE_NRF91 8191  </span><span class="comment">// Nordic hardware limitation</span></div>
</div><!-- fragment --><p> <b>Why</b>: nRF91 UART peripheral maximum buffer size limitation</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md139"></a>
Key Timing Parameters Summary</h2>
<ul>
<li><b>Baudrate</b>: 115200 bps (8N1 format)</li>
<li><b>Frame duration</b>: <b>87 ¬µs per byte</b> (exact UART timing)</li>
<li><b>Maximum telegram size</b>: <b>8191 bytes</b> (DSMR spec + nRF91 limit)</li>
<li><b>P1 device response delay</b>: <b>0-10 seconds</b> (DSMR spec)</li>
<li><b>Inter-byte timeout</b>: <b>392 ms</b> (50% of max telegram time)</li>
<li><b>Telegram timeout</b>: <b>784 ms</b> (max telegram + 10% margin)</li>
<li><b>Total timeout</b>: <b>10.8 seconds</b> (P1 delay + telegram time)</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md140"></a>
Multi-Layer Timeout Strategy</h2>
<p>The implementation uses multiple layers of timeout protection with precise calculations:</p>
<ol type="1">
<li><b>Inter-byte Timeout</b>: <b>392ms</b> (50% of max telegram time - detects end of transmission)</li>
<li><b>Telegram Timeout</b>: <b>784ms</b> (max telegram transmission time + 10% safety margin)</li>
<li><b>Response Timeout</b>: <b>10.8s</b> (DSMR P1 response delay + full telegram transmission)</li>
<li><b>Watchdog Timeout</b>: Configurable (build-time verified &gt; telegram timeout)</li>
</ol>
<p><b>Layered Protection Benefits</b>:</p><ul>
<li><b>Fast detection</b> of transmission end (392ms vs 10.8s)</li>
<li><b>Graceful handling</b> of slow P1 devices (up to 10s response time)</li>
<li><b>Hardware protection</b> against buffer overflow (8191 byte limit)</li>
<li><b>System stability</b> via watchdog backup (prevents permanent hangs)</li>
</ul>
<p>This multi-layer approach ensures the system never hangs, even with unresponsive or malfunctioning P1 devices. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
