<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="dark-mode">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- BEGIN opengraph metadata -->
<meta property="og:title" content="SolarResult Dinnis Core API Documentation" />
<meta property="og:description" content="API documentation for SolarResult Dinnis Core - IoT firmware for smart meter gateway device built with Zephyr RTOS on Nordic nRF9161" />
<!-- END opengraph metadata -->
<!-- Favicon -->
<link rel="icon" type="image/svg+xml" href="solar_result_white.svg">
<title>SolarResult Dinnis Core: P1 Module - DSMR Smart Meter Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript">
    // Initialize Doxygen Awesome features (dark mode only, no toggle)
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="solar_result_black.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SolarResult Dinnis Core
   </div>
   <div id="projectbrief">Dinnis Rev1.0.0 Firmware - IoT Gateway for DSMR P1 Smart Meters</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('p_one.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">P1 Module - DSMR Smart Meter Interface </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>De P1 module vormt de kern van de energiemeting in Dinnis. Via de P1 poort van DSMR slimme meters leest de module elektriciteits- en gasverbruiksdata uit, parsed deze, en publiceert geaggregeerde statistieken voor cloud upload. Deze module draait continu in een dedicated thread en moet robuust omgaan met verschillende UART situaties, timing requirements, en data validatie.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md110"></a>
Functionaliteit</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md111"></a>
Data Acquisitie van DSMR Meters</h3>
<p>DSMR slimme meters publiceren elke seconde een telegram via de P1 poort - een seriële UART verbinding (115200 baud, 8N1, no flow control). Een telegram is een ASCII bestand bestaande uit OBIS codes (Object Identification System) die energie metingen representeren. De module luistert naar deze telegrams en extract relevante metingen:</p>
<p><b>Elektriciteit:</b></p><ul>
<li>Cumulatieve energie verbruik (van net) - tarief 1 en 2</li>
<li>Cumulatieve energie teruglevering (naar net) - tarief 1 en 2 <br  />
</li>
<li>Actueel vermogen verbruik (W)</li>
<li>Actueel vermogen teruglevering (W)</li>
</ul>
<p><b>Gas:</b></p><ul>
<li>Cumulatief gasverbruik (m³)</li>
<li>Timestamp van laatste gas meting (gas wordt elk uur geüpdatet, niet elke seconde)</li>
</ul>
<p>Elk OBIS veld heeft een vaste structuur: <span class="tt">OBIS-code(value*unit)</span>. Bijvoorbeeld: </p><div class="fragment"><div class="line">1-0:1.8.1(002841.463*kWh)  → Verbruik tarief 1: 2841.463 kWh</div>
<div class="line">1-0:2.8.1(001244.927*kWh)  → Teruglevering tarief 1: 1244.927 kWh</div>
<div class="line">1-0:1.7.0(00.342*kW)       → Actueel verbruik: 342W</div>
<div class="line">0-1:24.2.3(241022130000W)(00456.789*m3)  → Gas: 456.789 m³ @ timestamp</div>
</div><!-- fragment --><p>De parser converteert deze fixed-point decimale waarden (6 decimalen precisie) direct naar integer milliwatt/milliwattuur representatie. Geen floating point conversies - de OBIS data is intern al integer fixed-point, dus door dit te behouden elimineren we FPU overhead volledig.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md112"></a>
UART Async API &amp; Timing</h3>
<p>De module gebruikt Zephyr's UART Async API met RX timeout detectie. Dit is cruciaal omdat DSMR telegrams variabel van lengte zijn (500-1500 bytes) en niet op een voorspelbare tijd eindigen. De UART events die we verwerken:</p>
<p><b>UART_RX_RDY</b>: Data beschikbaar in buffer</p><ul>
<li>Incrementeel bufferen van telegram data</li>
<li>CRC validatie nog niet mogelijk (telegram incomplete)</li>
</ul>
<p><b>UART_RX_DISABLED</b>: UART ontvangst gestopt</p><ul>
<li>Gebeurt na timeout (geen nieuwe data binnen timeout window)</li>
<li>Trigger voor "telegram compleet" → start parsing</li>
<li>Dit is het primaire einde-detectie mechanisme</li>
</ul>
<p><b>UART_RX_STOPPED</b>: Buffer vol of andere stop conditie</p><ul>
<li>Fallback mechanisme</li>
<li>Trigger ook parsing (best effort)</li>
</ul>
<p><b>UART_RX_BUF_RELEASED</b>: Buffer teruggegeven door driver</p><ul>
<li>Huishoudelijke taak, geen actie vereist</li>
</ul>
<p>De timing is als volgt: DSMR stuurt om de ~1 seconde een telegram (duur: ~500-800ms voor volledig telegram). Na het telegram is er stilte. De UART RX timeout detecteert deze stilte en triggert <span class="tt">UART_RX_DISABLED</span> → dit signaal betekent "telegram compleet, ga parsen".</p>
<p><b>Waarom timeout-based i.p.v. newline detectie?</b> DSMR telegrams eindigen met een CRC checksum, maar de structuur is: </p><div class="fragment"><div class="line">/ISK5\2M550T-1012</div>
<div class="line">...data...</div>
<div class="line">!xxxx  ← CRC in hex</div>
</div><!-- fragment --><p>De <span class="tt">!</span> marker zou je kunnen gebruiken, maar:</p><ul>
<li>Je moet toch de hele buffer bufferen (voor CRC check)</li>
<li>Timeout is betrouwbaarder (werkt ook bij corrupte <span class="tt">!</span> marker)</li>
<li>Zephyr UART Async timeout is hardware-assisted (efficient)</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md113"></a>
UART Timing Calculations - Fundamentals</h3>
<p>De timing parameters zijn niet arbitrair gekozen - ze zijn nauwkeurig berekend gebaseerd op UART hardware karakteristieken en DSMR specificaties. Hier is de volledige uitwerking:</p>
<p><b>UART Frame Timing (8N1 format)</b>:</p><ul>
<li>1 start bit + 8 data bits + 1 stop bit = <b>10 bits per byte</b></li>
<li>Bij 115200 bps: <span class="tt">115200 bits/s ÷ 10 bits/byte = 11520 bytes/s</span></li>
<li><b>Frame duration per byte</b>: <span class="tt">1,000,000 µs ÷ 11520 = 86.8 µs/byte</span></li>
</ul>
<p>Code implementatie: </p><div class="fragment"><div class="line"><span class="preprocessor">#define P_ONE_UART_FRAME_DURATION_USEC \</span></div>
<div class="line"><span class="preprocessor">    (unsigned long)(1000 * 1000 / (P_ONE_UART_BAUD_RATE / 10) + 1)</span></div>
<div class="line"><span class="comment">// Resultaat: (1,000,000 / (115200 / 10)) + 1 = ~87 µs</span></div>
</div><!-- fragment --><p><b>Maximum Telegram Transmission Time</b>:</p>
<p>DSMR v5.0.2 specificatie: maximum telegram size = <b>8191 bytes</b> (ook nRF91 UART buffer limiet)</p>
<p>Basis berekening:</p><ul>
<li><span class="tt">8191 bytes × 87 µs/byte = 712,617 µs</span> (≈712.6 ms)</li>
</ul>
<p>Met 10% safety margin (clock drift, processing delays):</p><ul>
<li><span class="tt">712,617 µs × 1.1 = 783,879 µs</span> (≈783.9 ms)</li>
</ul>
<p>Code: </p><div class="fragment"><div class="line"><span class="preprocessor">#define P_ONE_UART_MAX_TELEGRAM_TIMEOUT_USEC \</span></div>
<div class="line"><span class="preprocessor">    (P_ONE_UART_MAX_TELEGRAM_SIZE * P_ONE_UART_FRAME_DURATION_USEC * 1.1)</span></div>
<div class="line"><span class="comment">// Resultaat: 8191 × 87 × 1.1 = ~784 ms</span></div>
</div><!-- fragment --><p><b>Inter-byte Timeout (UART RX timeout)</b>:</p>
<p>Dit is de timeout die detecteert wanneer een telegram compleet is (geen nieuwe data meer).</p>
<p>Berekening: 50% van maximum telegram time</p><ul>
<li><span class="tt">783,879 µs × 0.5 = 391,940 µs</span> (≈392 ms)</li>
</ul>
<p>Waarom 50%?</p><ul>
<li><b>Te kort</b>: False positives tijdens normale transmissie</li>
<li><b>Te lang</b>: Trage error detectie, vertraagde processing</li>
<li><b>392 ms</b>: Balans tussen betrouwbaarheid en responsiveness</li>
</ul>
<p>Code gebruik in <span class="tt">uart_rx_enable()</span>: </p><div class="fragment"><div class="line">uart_rx_enable(<a class="code hl_variable" href="p__one_8c.html#a660f23134aaae43c9ff2c6096fa59342">uart_dev</a>, <a class="code hl_variable" href="p__one_8c.html#a225d537524678c83d06f5fbbbbc3588f">p_one_uart_rx_buf</a>, <a class="code hl_define" href="p__one_8c.html#a1f25fe45d891de244a8135ae02fc9265">UART_RX_BUF_SIZE</a>,</div>
<div class="line">               <a class="code hl_define" href="p__one_8c.html#ad20309c579792abe59be2c8c7bb0fd68">P_ONE_UART_MAX_TELEGRAM_TIMEOUT_USEC</a> * 0.5);  <span class="comment">// 392 ms</span></div>
<div class="ttc" id="ap__one_8c_html_a1f25fe45d891de244a8135ae02fc9265"><div class="ttname"><a href="p__one_8c.html#a1f25fe45d891de244a8135ae02fc9265">UART_RX_BUF_SIZE</a></div><div class="ttdeci">#define UART_RX_BUF_SIZE</div><div class="ttdef"><b>Definition</b> <a href="p__one_8c_source.html#l00069">p_one.c:69</a></div></div>
<div class="ttc" id="ap__one_8c_html_a225d537524678c83d06f5fbbbbc3588f"><div class="ttname"><a href="p__one_8c.html#a225d537524678c83d06f5fbbbbc3588f">p_one_uart_rx_buf</a></div><div class="ttdeci">static uint8_t p_one_uart_rx_buf[(8191)]</div><div class="ttdef"><b>Definition</b> <a href="p__one_8c_source.html#l00223">p_one.c:223</a></div></div>
<div class="ttc" id="ap__one_8c_html_a660f23134aaae43c9ff2c6096fa59342"><div class="ttname"><a href="p__one_8c.html#a660f23134aaae43c9ff2c6096fa59342">uart_dev</a></div><div class="ttdeci">static const struct device * uart_dev</div><div class="ttdef"><b>Definition</b> <a href="p__one_8c_source.html#l00220">p_one.c:220</a></div></div>
<div class="ttc" id="ap__one_8c_html_ad20309c579792abe59be2c8c7bb0fd68"><div class="ttname"><a href="p__one_8c.html#ad20309c579792abe59be2c8c7bb0fd68">P_ONE_UART_MAX_TELEGRAM_TIMEOUT_USEC</a></div><div class="ttdeci">#define P_ONE_UART_MAX_TELEGRAM_TIMEOUT_USEC</div><div class="ttdef"><b>Definition</b> <a href="p__one_8c_source.html#l00047">p_one.c:47</a></div></div>
</div><!-- fragment --><p><b>Total Response Timeout</b>:</p>
<p>DSMR specificatie: P1 apparaat mag tot <b>10 seconden</b> wachten na Data Request voordat telegram start.</p>
<p>Totale timeout berekening:</p><ul>
<li>P1 response delay: <b>10,000 ms</b></li>
<li>Maximum telegram transmission: <b>783.9 ms</b></li>
<li><b>Totaal: 10,783.9 ms</b> (≈10.8 seconden)</li>
</ul>
<p>Code: </p><div class="fragment"><div class="line"><span class="preprocessor">#define P_ONE_DATA_REQUEST_RESPONSE_TIMEOUT_MSEC \</span></div>
<div class="line"><span class="preprocessor">    (10000 + P_ONE_UART_MAX_TELEGRAM_TIMEOUT_USEC / 1000)</span></div>
<div class="line"><span class="comment">// Resultaat: 10000 + 784 = 10,784 ms</span></div>
</div><!-- fragment --><p><b>Edge Case Scenarios</b>:</p>
<p><em>Scenario 1: Slow P1 Device</em> </p><div class="fragment"><div class="line">t=0ms:      Assert Data Request pin</div>
<div class="line">t=9999ms:   P1 start transmissie (net binnen 10s spec)</div>
<div class="line">t=10783ms:  Transmissie compleet (784ms later)</div>
<div class="line">→ Success, binnen 10.8s timeout</div>
</div><!-- fragment --><p><em>Scenario 2: Maximum Length Telegram</em> </p><div class="fragment"><div class="line">8191 bytes × 87 µs/byte = 712.6ms base time</div>
<div class="line">+ 10% margin = 783.9ms toegestaan</div>
<div class="line">+ P1 response delay = max 10s</div>
<div class="line">= Totaal budget: 10.784s ✓</div>
</div><!-- fragment --><p><em>Scenario 3: Inter-byte Timeout Trigger</em> </p><div class="fragment"><div class="line">Bytes arriveren normaal (87 µs intervals)</div>
<div class="line">Gap &gt; 392ms gedetecteerd</div>
<div class="line">→ Einde telegram aangenomen</div>
<div class="line">→ UART_RX_DISABLED event</div>
</div><!-- fragment --><p><b>Watchdog Dependency</b>:</p>
<p>Kritiek: UART timeout moet korter zijn dan watchdog timeout! </p><div class="fragment"><div class="line"><a class="code hl_function" href="p__one_8c.html#a3f48fcbc19fe59b24bda25731cea5c00">BUILD_ASSERT</a>((<a class="code hl_define" href="p__one_8c.html#ad20309c579792abe59be2c8c7bb0fd68">P_ONE_UART_MAX_TELEGRAM_TIMEOUT_USEC</a> / 1000) &lt;</div>
<div class="line">             (CONFIG_APP_P_ONE_MODULE_WATCHDOG_TIMEOUT_SECONDS * 1000),</div>
<div class="line">             <span class="stringliteral">&quot;UART timeout must be less than watchdog timeout&quot;</span>);</div>
<div class="ttc" id="ap__one_8c_html_a3f48fcbc19fe59b24bda25731cea5c00"><div class="ttname"><a href="p__one_8c.html#a3f48fcbc19fe59b24bda25731cea5c00">BUILD_ASSERT</a></div><div class="ttdeci">BUILD_ASSERT(((8191 *(unsigned long)(1000 *1000/(DT_PROP(DT_NODELABEL(uart3), current_speed)/10)+1) *1.1)/1000)&lt;(CONFIG_APP_P_ONE_MODULE_WATCHDOG_TIMEOUT_SECONDS *1000), &quot;UART timeout must be less than watchdog timeout&quot;)</div></div>
</div><!-- fragment --><p>Anders: watchdog reset tijdens valide telegram ontvangst → reboot → data loss.</p>
<p><b>Timing Parameters Samenvatting</b>:</p><ul>
<li><b>Baudrate</b>: 115200 bps (8N1)</li>
<li><b>Frame duration</b>: <b>87 µs/byte</b> (exact UART timing)</li>
<li><b>Max telegram size</b>: <b>8191 bytes</b> (DSMR spec + nRF91 limiet)</li>
<li><b>P1 response delay</b>: <b>0-10s</b> (DSMR spec)</li>
<li><b>Inter-byte timeout</b>: <b>392 ms</b> (50% van max telegram)</li>
<li><b>Telegram timeout</b>: <b>784 ms</b> (max telegram + 10% margin)</li>
<li><b>Total timeout</b>: <b>10.8s</b> (P1 delay + telegram)</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md114"></a>
OBIS Parsing &amp; Data Conversie</h3>
<p>Elk OBIS veld wordt geparsed door een dedicated parser functie. De parsers zijn type-specifiek:</p>
<p><b>Fixed-point numerieke waarden</b> (<span class="tt">obis_parse_fixed_point</span>): </p><div class="fragment"><div class="line">1-0:1.8.1(002841.463*kWh)</div>
<div class="line">          └─────┬─────┘</div>
<div class="line">         Fixed point (6 decimalen)</div>
<div class="line">         </div>
<div class="line">Parser extraheert: <span class="stringliteral">&quot;002841.463&quot;</span></div>
<div class="line">→ int32_t = 2841463 (milliwattuur)</div>
<div class="line">→ * 1000 = 2841463000 (microwattuur? Nee, Wh!)</div>
<div class="line">→ Opslag: 2841463 Wh (int32_t, 4 bytes)</div>
</div><!-- fragment --><p>De conversie is slim: OBIS geeft kWh, wij willen Wh integer. Dus <span class="tt">2841.463 kWh * 1000 = 2841463 Wh</span>. Bij vermogen: <span class="tt">0.342 kW * 1000 = 342W</span>. Alles blijft integer, geen floating point.</p>
<p><b>Timestamps</b> (<span class="tt">obis_parse_timestamp</span>): </p><div class="fragment"><div class="line">0-1:24.2.3(241022130000W)(...)</div>
<div class="line">           └────┬─────┘</div>
<div class="line">            YYMMDDHHmmssX</div>
<div class="line">            </div>
<div class="line">Parser extraheert: <span class="stringliteral">&quot;241022130000&quot;</span></div>
<div class="line">→ Jaar: 24, Maand: 10, Dag: 22</div>
<div class="line">→ Uur: 13, Min: 00, Sec: 00</div>
<div class="line">→ Convert naar UNIX timestamp (ms sinds epoch)</div>
</div><!-- fragment --><p>De <span class="tt">X</span> suffix is seizoen indicator (W=winter, S=zomer), relevant voor DST.</p>
<p><b>Strings</b> (<span class="tt">obis_parse_string</span>):</p><ul>
<li>Gebruikt voor versie nummers, meter ID's (future use)</li>
</ul>
<p>Alle parsers valideren input via <span class="tt">obis_sanity_check</span>: minimaal 10 karakters, bevat <span class="tt">(</span>, <span class="tt">*</span>, <span class="tt">)</span>. Dit voorkomt crashes op corrupte data.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md115"></a>
Rolling Statistics &amp; Sampling</h3>
<p>Hier wordt het interessant. We willen niet elke seconde data naar de cloud sturen (te veel data verkeer, kosten, energie). In plaats daarvan verzamelen we samples over een periode en berekenen statistieken.</p>
<p><b>Sampling flow:</b> </p><div class="fragment"><div class="line">t=0s     ACQ_TRIGGER → Meet vermogen → Sample 1 (bijv. 342W verbruik)</div>
<div class="line">t=30s    ACQ_TRIGGER → Meet vermogen → Sample 2 (bijv. 520W verbruik)</div>
<div class="line">t=60s    ACQ_TRIGGER → Meet vermogen → Sample 3 (bijv. 410W verbruik)</div>
<div class="line">...</div>
<div class="line">t=570s   ACQ_TRIGGER → Meet vermogen → Sample 20 (bijv. 380W verbruik)</div>
<div class="line">t=600s   PUBLISH → Bereken stats → Publiceer → Reset</div>
</div><!-- fragment --><p>Per 20 samples (10 minuten bij 30s interval) berekenen we:</p><ul>
<li><b>Average</b>: Gemiddelde vermogen over periode (som / count)</li>
<li><b>Maximum</b>: Hoogste piek + timestamp (voor peak shaving analyse)</li>
<li><b>Minimum</b>: Laagste waarde (baseline verbruik)</li>
</ul>
<p><b>Waarom separate consumed vs delivered stats?</b></p>
<p>Dit is een cruciale design keuze. Alternatief was "net power" (consumed - delivered), maar dat maskeert informatie:</p>
<p><b>Scenario:</b> Om 12:00 verbruik je 1.5kW (huishouden) terwijl zonnepanelen 3kW produceren.</p><ul>
<li><b>Net power</b>: -1.5kW (teruglevering) <br  />
 ❌ Je ziet niet dat je 1.5kW verbruikt ❌ Je ziet niet dat je 3kW produceert</li>
<li><b>Separate stats</b>: consumed=1.5kW, delivered=3kW <br  />
 ✅ Volledig inzicht in gedrag ✅ DEV optimalisatie mogelijk (meer verbruiken om teruglevering te verminderen) ✅ Peak shaving mogelijk (piekverbruik identificeren, ongeacht opwek)</li>
</ul>
<p><b>Use case - Peak Shaving:</b> <br  />
 Stats tonen <span class="tt">power_consumed_max_w = 4.5kW @ 08:00</span>. Analyse: koffie (1.2kW) + oven (2.5kW) + wasmachine (0.8kW) = 4.5kW piek. Actie: verschuif wasmachine naar 10:00 → nieuwe max = 3.7kW → lagere netaansluitkosten.</p>
<p><b>Use case - DEV Optimalisatie:</b> <br  />
 Stats tonen <span class="tt">delivered_avg = 3.5kW</span> van 12:00-14:00. Dit betekent teveel teruglevering (verlies bij lage terugleveringsvergoeding). Actie: start wasmachine + vaatwasser om 13:00 (tijdens zonnige uren) → vermindert teruglevering, verhoogt zelfverbruik.</p>
<p>De statistics worden bijgehouden in een <span class="tt">smart_meter_data</span> struct met aparte velden voor consumed en delivered. Na elke sample: </p><div class="fragment"><div class="line"><a class="code hl_function" href="p__one_8c.html#a727fc9db3c54db192dd4a16af246e323">update_rolling_stats</a>(&amp;rolling_stats, current_sample);</div>
<div class="line"><span class="comment">// Intern:</span></div>
<div class="line"><span class="comment">// - Update sum (voor avg)</span></div>
<div class="line"><span class="comment">// - Check max (+ timestamp)</span></div>
<div class="line"><span class="comment">// - Check min</span></div>
<div class="ttc" id="ap__one_8c_html_a727fc9db3c54db192dd4a16af246e323"><div class="ttname"><a href="p__one_8c.html#a727fc9db3c54db192dd4a16af246e323">update_rolling_stats</a></div><div class="ttdeci">static void update_rolling_stats(void)</div><div class="ttdoc">Update rolling statistics with new P1 measurement.</div><div class="ttdef"><b>Definition</b> <a href="p__one_8c_source.html#l00353">p_one.c:353</a></div></div>
</div><!-- fragment --><p>Bij PUBLISH trigger: </p><div class="fragment"><div class="line">p1_msg.power_consumed_avg_w = rolling_stats_consumed.sum / rolling_stats_consumed.count;</div>
<div class="line">p1_msg.power_consumed_max_w = rolling_stats_consumed.max;</div>
<div class="line">p1_msg.power_consumed_max_timestamp = rolling_stats_consumed.max_timestamp;</div>
<div class="line"><span class="comment">// ... idem voor delivered</span></div>
<div class="line"><a class="code hl_function" href="p__one_8c.html#a5ead751644738be541e2e3b0fa06717e">reset_rolling_stats</a>(&amp;rolling_stats_consumed);</div>
<div class="line"><a class="code hl_function" href="p__one_8c.html#a5ead751644738be541e2e3b0fa06717e">reset_rolling_stats</a>(&amp;rolling_stats_delivered);</div>
<div class="ttc" id="ap__one_8c_html_a5ead751644738be541e2e3b0fa06717e"><div class="ttname"><a href="p__one_8c.html#a5ead751644738be541e2e3b0fa06717e">reset_rolling_stats</a></div><div class="ttdeci">static void reset_rolling_stats(void)</div><div class="ttdoc">Reset rolling statistics.</div><div class="ttdef"><b>Definition</b> <a href="p__one_8c_source.html#l00326">p_one.c:326</a></div></div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md116"></a>
Gas Meting &amp; Thermische Vermogen Conversie</h3>
<p>Gas is speciaal: DSMR meters updaten gas slechts elk uur (niet elke seconde zoals elektriciteit). Het OBIS veld bevat zowel de gas waarde als een timestamp:</p>
<div class="fragment"><div class="line">0-1:24.2.3(241022130000W)(00456.789*m3)</div>
<div class="line">           └────┬─────┘    └───┬────┘</div>
<div class="line">           Timestamp      Gas m³</div>
</div><!-- fragment --><p>We extracten:</p><ul>
<li><span class="tt">gas_consumed_m3</span>: Cumulatieve meterstand (int32_t, in milli-m³)</li>
<li>Gas timestamp: Wanneer deze meting gedaan is</li>
</ul>
<p>Voor betekenisvolle statistieken willen we gas in "vermogen" uitdrukken (net als elektriciteit in Watt). We berekenen thermisch vermogen:</p>
<div class="fragment"><div class="line">Aanname: Aardgas = 9.769 kWh/m³ (typisch Nederlands aardgas)</div>
<div class="line"> </div>
<div class="line">Delta gas = huidige m³ - vorige m³</div>
<div class="line">Delta tijd = huidig timestamp - vorig timestamp</div>
<div class="line">Thermisch vermogen = (delta_gas * 9.769 kWh/m³) / (delta_tijd in uur)</div>
</div><!-- fragment --><p>Voorbeeld: 0.050 m³ gas verbruikt in 1 uur → <span class="tt">0.050 * 9.769 = 0.488 kWh/h = 488W</span> thermisch vermogen.</p>
<p>Dit geeft ons <span class="tt">gas_power_avg_w</span>, <span class="tt">gas_power_max_w</span>, etc. - vergelijkbaar met elektriciteit stats. Zo kan je totale energiehuishouding analyseren (elektra + gas).</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md117"></a>
ZBUS Integratie</h2>
<p>De module is volledig event-driven via ZBUS. Er zijn twee hoofdtriggers:</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md118"></a>
ACQ_TRIGGER - Data Acquisitie</h3>
<p>Published door Timing module (bijv. elke 30 seconden). Bij ontvangst:</p><ol type="1">
<li>Wacht op UART telegram (via <span class="tt">UART_RX_DISABLED</span> event)</li>
<li>Parse OBIS data</li>
<li>Converteer naar integers</li>
<li>Update rolling statistics</li>
<li>Klaar - wacht op volgende trigger</li>
</ol>
<h3 class="doxsection"><a class="anchor" id="autotoc_md119"></a>
PUBLISH - Statistieken Publiceren</h3>
<p>Published door Timing module (bijv. elke 10 minuten). Bij ontvangst:</p><ol type="1">
<li>Bereken finale statistieken (avg/max/min)</li>
<li>Vul <span class="tt"><a class="el" href="structp__one__msg.html" title="P_ONE module message structure.">p_one_msg</a></span> struct:<ul>
<li>Timestamp (huidige tijd)</li>
<li>Energie totalen (4 velden: consumed/delivered × tarief1/2)</li>
<li>Gas totaal + timestamp</li>
<li>Vermogen statistieken (consumed: avg/max/min + timestamps)</li>
<li>Vermogen statistieken (delivered: avg/max/min + timestamps)</li>
<li>Gas vermogen statistieken (avg/max/min + timestamps)</li>
</ul>
</li>
<li>Publish op <span class="tt">P_ONE_CHAN</span> (message queue luistert)</li>
<li>Reset rolling stats voor nieuwe periode</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="autotoc_md120"></a>
State Machine</h2>
<p>De module gebruikt SMF (State Machine Framework) met drie states:</p>
<p><b>INIT → ACQUIRING → OPERATIONAL</b></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md121"></a>
INIT</h3>
<ul>
<li>Setup UART (115200 baud, async RX)</li>
<li>Alloceer RX buffers (dubbel buffering)</li>
<li>Initialiseer rolling stats structs</li>
<li>→ ACQUIRING</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md122"></a>
ACQUIRING</h3>
<p>Wacht op eerste valide telegram:</p><ul>
<li>Ontvang UART data</li>
<li>Parse + valideer (CRC check)</li>
<li>Bij success: → OPERATIONAL</li>
<li>Bij failure: blijf proberen (robuustheid)</li>
</ul>
<p>De reden voor deze separate state: bij boot is de UART state onbekend (meter kan midden in telegram zitten). Door eerste telegram als "sync" te gebruiken, weten we daarna dat we aligned zijn.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md123"></a>
OPERATIONAL</h3>
<p>Normale operatie:</p><ul>
<li><b>ACQ_TRIGGER</b> → acquire + update stats</li>
<li><b>PUBLISH</b> → publiceer + reset</li>
<li>Loop forever</li>
</ul>
<p>Foutafhandeling: als parsing faalt (CRC error, corrupt data), loggen we error maar blijven operationeel. Volgende telegram is nieuwe kans. Dit voorkomt dat één corrupt telegram de hele module blokkeert.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md124"></a>
Technische Diepgang</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md125"></a>
Waarom Integer Fixed-Point?</h3>
<p>DSMR OBIS data is inherent fixed-point decimaal (6 cijfers na comma). De oude aanpak: </p><div class="fragment"><div class="line">OBIS &quot;002841.463*kWh&quot; </div>
<div class="line">→ Parse naar double (2841.463) </div>
<div class="line">→ Convert naar Wh (2841463.0)</div>
<div class="line">→ Cast naar int32_t (2841463)</div>
</div><!-- fragment --><p>Probleem: dubbele conversie (string→double→int), FPU nodig (context switch overhead), 8 bytes per double.</p>
<p>Nieuwe aanpak: </p><div class="fragment"><div class="line">OBIS &quot;002841.463*kWh&quot;</div>
<div class="line">→ Parse direct naar int32_t (2841463) via string parsing</div>
<div class="line">→ Klaar</div>
</div><!-- fragment --><p>Implementatie: <span class="tt"><a class="el" href="p__one_8c.html#a25177287547d8c49377f0af372a4371c" title="Convert OBIS fixed-point value to milli-units (int32_t, no FPU)">obis_fixed_point_to_milli()</a></span> gebruikt string manipulatie om de decimale punt te verwijderen en leidt precision af uit positie. Geen <span class="tt">atof()</span>, geen FPU.</p>
<p>Voordelen:</p><ul>
<li>Elimineer FPU overhead (significant op Cortex-M33 zonder FPU unit)</li>
<li>Halveer geheugen (4 bytes vs 8 bytes per veld)</li>
<li>Behoud precisie (6 decimalen voldoende voor kWh metingen)</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md126"></a>
CRC16 Validatie</h3>
<p>DSMR telegrams eindigen met CRC16 checksum: </p><div class="fragment"><div class="line">/ISK5\2M550T-1012</div>
<div class="line"> </div>
<div class="line">1-0:1.8.1(002841.463*kWh)</div>
<div class="line">...</div>
<div class="line">!F3A2  ← CRC16 in hex</div>
</div><!-- fragment --><p>De CRC wordt berekend over alles vanaf <span class="tt">/</span> tot <span class="tt">!</span> (exclusief). We implementeren CRC16 volgens DSMR spec (polynomial 0xA001, init 0x0000).</p>
<p>Validatie flow:</p><ol type="1">
<li>Parse CRC waarde na <span class="tt">!</span> (hex string → int)</li>
<li>Bereken CRC over buffer (0 tot <span class="tt">!</span> positie)</li>
<li>Vergelijk: <span class="tt">if (calculated != parsed) → ERROR</span></li>
</ol>
<p>Als CRC faalt → discard telegram, wacht op volgende. Geen retry logic (meter stuurt elk seconde nieuw telegram anyway).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md127"></a>
UART Buffer Management</h3>
<p>We gebruiken dual buffering om geen data te missen tijdens parsing:</p>
<div class="fragment"><div class="line">Buffer A (2048 bytes) ──┐</div>
<div class="line">                         ├──&gt; UART DMA</div>
<div class="line">Buffer B (2048 bytes) ──┘</div>
<div class="line"> </div>
<div class="line">State: RECEIVING in Buffer A</div>
<div class="line">UART_RX_RDY → Data accumulating in A</div>
<div class="line">UART_RX_DISABLED → Telegram compleet</div>
<div class="line">  → Start parsing A</div>
<div class="line">  → Switch UART naar Buffer B</div>
<div class="line">  → Parse A in parallel met nieuwe RX naar B</div>
</div><!-- fragment --><p>Buffer size: 2048 bytes is ruim voldoende (DSMR max ~1500 bytes). Geen dynamische allocatie - static buffers in thread stack.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md128"></a>
Edge Cases &amp; Robuustheid</h3>
<p><b>Scenario 1: UART Error tijdens ontvangst</b> <br  />
 → Event: <span class="tt">UART_RX_DISABLED</span> met error code <br  />
 → Actie: Log error, discard buffer, restart RX <br  />
 → Impact: Skip één telegram (1s data loss), auto-recover</p>
<p><b>Scenario 2: Corrupt telegram (CRC fail)</b> <br  />
 → Detectie: CRC mismatch <br  />
 → Actie: Log warning, discard, wacht op volgende <br  />
 → Impact: Skip één sample (bij 20 samples/periode is 1 loss acceptable)</p>
<p><b>Scenario 3: OBIS veld niet gevonden</b> <br  />
 → Detectie: Parser returnt error <br  />
 → Actie: Gebruik vorige waarde (stale data) of 0 (first run) <br  />
 → Impact: Graceful degradation (liever incomplete data dan crash)</p>
<p><b>Scenario 4: Buffer overflow (telegram &gt; 2048 bytes)</b> <br  />
 → Event: <span class="tt">UART_RX_STOPPED</span> <br  />
 → Actie: Parse wat we hebben (best-effort), log warning <br  />
 → Impact: Mogelijk incomplete data, maar geen crash</p>
<p><b>Scenario 5: Gas timestamp niet geüpdatet</b> <br  />
 → Detectie: Zelfde timestamp als vorige sample <br  />
 → Actie: Gebruik cached waarde, skip statistics update <br  />
 → Impact: Gas stats blijven stabiel (gas update is elk uur, niet elk sample)</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md129"></a>
Timing &amp; Watchdog</h3>
<p>De module registreert zich bij Task Watchdog met een feed interval van: </p><div class="fragment"><div class="line">Feed interval = (ACQ_INTERVAL + PARSE_MARGIN) * 2</div>
<div class="line">              = (30s + 5s) * 2 = 70s</div>
<div class="line"> </div>
<div class="line">Rationale:</div>
<div class="line">- ACQ_INTERVAL: Maximale tijd tussen acquisitie triggers</div>
<div class="line">- PARSE_MARGIN: Worst-case parsing tijd</div>
<div class="line">- × 2: Safety margin voor jitter</div>
</div><!-- fragment --><p>Als de thread langer dan 70s niet feed → watchdog reset. Dit voorkomt silent failures (bijv. UART hang, infinite loop in parser).</p>
<p>De thread feed-punt is na elke succesvolle acquisitie en na elke publish. Tijdens normale operatie (30s triggers) feed je dus elke ~30s → ruim binnen 70s limiet.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md130"></a>
Configuratie</h2>
<p>Kconfig opties:</p>
<ul>
<li><span class="tt">CONFIG_P_ONE_MODULE</span>: Enable P1 module (default=y)</li>
<li><span class="tt">CONFIG_P_ONE_THREAD_STACK_SIZE</span>: Thread stack size (default=4096)</li>
<li><span class="tt">CONFIG_P_ONE_THREAD_PRIORITY</span>: Thread priority (default=5)</li>
<li><span class="tt">CONFIG_P_ONE_UART_DEVICE</span>: UART device name (default="UART_1")</li>
<li><span class="tt">CONFIG_P_ONE_UART_BAUDRATE</span>: UART baudrate (default=115200, DSMR fixed)</li>
</ul>
<p>Runtime configuratie via Settings subsystem:</p><ul>
<li>Gas calorific value (kWh/m³): Voor thermische vermogen berekening, default 9.769</li>
<li>CRC validation enable/disable: Voor debug (skip corrupt telegrams tijdens ontwikkeling)</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md131"></a>
Data Output</h2>
<p>De <span class="tt"><a class="el" href="structp__one__msg.html" title="P_ONE module message structure.">p_one_msg</a></span> struct bevat:</p>
<p><b>Timestamp</b>: Publicatie tijdstip (UNIX ms)</p>
<p><b>Energie (cumulatief, in Wh):</b></p><ul>
<li><span class="tt">energy_consumed_wh_tariff1/2</span>: Totaal verbruik van net</li>
<li><span class="tt">energy_delivered_wh_tariff1/2</span>: Totaal teruglevering naar net</li>
</ul>
<p><b>Gas (cumulatief + timestamp):</b></p><ul>
<li><span class="tt">gas_consumed_m3</span>: Totaal gasverbruik (milli-m³)</li>
<li>Gas timestamp embedded in OBIS data (voor staleness detectie)</li>
</ul>
<p><b>Vermogen statistieken (over sample periode, in W):</b></p>
<p><em>Consumed (van net):</em></p><ul>
<li><span class="tt">power_consumed_avg_w</span>: Gemiddeld verbruik</li>
<li><span class="tt">power_consumed_max_w</span>: Piek verbruik <br  />
</li>
<li><span class="tt">power_consumed_max_timestamp</span>: Wanneer piek optrad</li>
<li><span class="tt">power_consumed_min_w</span>: Baseline verbruik</li>
</ul>
<p><em>Delivered (naar net):</em></p><ul>
<li><span class="tt">power_delivered_avg_w</span>: Gemiddelde teruglevering</li>
<li><span class="tt">power_delivered_max_w</span>: Piek teruglevering</li>
<li><span class="tt">power_delivered_max_timestamp</span>: Wanneer piek optrad <br  />
</li>
<li><span class="tt">power_delivered_min_w</span>: Minimum teruglevering</li>
</ul>
<p><em>Gas (thermisch vermogen in W):</em></p><ul>
<li><span class="tt">gas_power_avg_w</span>: Gemiddeld gas thermisch vermogen</li>
<li><span class="tt">gas_power_max_w</span>: Piek gas verbruik</li>
<li><span class="tt">gas_power_max_timestamp</span>: Wanneer piek optrad</li>
<li><span class="tt">gas_power_min_w</span>: Minimum gas verbruik</li>
</ul>
<p>Deze data wordt geconsumeerd door Message Queue module (combineert met pulse data) en uiteindelijk geüpload naar nRF Cloud voor analyse en visualisatie. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
